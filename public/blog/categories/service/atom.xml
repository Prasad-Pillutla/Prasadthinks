<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: service | Prasad Thinks]]></title>
  <link href="http://prasad-pillutla.github.io/Prasadthinks/blog/categories/service/atom.xml" rel="self"/>
  <link href="http://prasad-pillutla.github.io/Prasadthinks/"/>
  <updated>2016-09-24T17:31:17+00:00</updated>
  <id>http://prasad-pillutla.github.io/Prasadthinks/</id>
  <author>
    <name><![CDATA[Prasad]]></name>
    <email><![CDATA[Prasad.pillu@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Azure Scheduler can post to Azure Service Bus Queue and Topic]]></title>
    <link href="http://prasad-pillutla.github.io/Prasadthinks/blog/2015/07/10/azure-scheduler-can-post-to-azure-service-bus-queue-and-topic/"/>
    <updated>2015-07-10T18:53:09+00:00</updated>
    <id>http://prasad-pillutla.github.io/Prasadthinks/blog/2015/07/10/azure-scheduler-can-post-to-azure-service-bus-queue-and-topic</id>
    <content type="html"><![CDATA[<p>Azure Scheduler today doesn’t allow submitting long running jobs to Service bus queues/topics but does allow submitting them to storage queues. What if, there is a requirement to submit jobs to service bus queues/topics so that features like duplicate detection can be leveraged to eliminate duplicate jobs from getting executed. One can submit messages to Service bus queue from Scheduler dashboard using REST APIs. Here is how we do it</p>

<p><img src="/images/SB.jpg" alt="Job Action" /></p>

<p>Select <strong>Post</strong> method in Scheduler Job dashboard, which displays above template. URI will represent Queue or Topic where ever we want to send message. URI template for Service bus would be <em>http{s}://{serviceNamespace}.servicebus.windows.net/{queuePath|topicPath}/messages</em></p>

<p>we can add timeout for POST request by appending timeout at the end of Uri. POST Uri with timeout will be <em>http{s}://{serviceNamespace}.servicebus.windows.net/{queuePath|topicPath}/messages?timeout=</em></p>

<p><strong>example</strong>: <em>http{s}://{serviceNamespace}.servicebus.windows.net/{queuePath|topicPath}/messages?timeout=60</em></p>

<p><strong>BrokerProperties</strong> allows one to set properties like TimeToLive, MessageId, Label etc… These properties have to beaded in Json format and this is mandatory</p>

<p><strong>Authorization</strong> property is used to define AccessToken.</p>

<p><strong>Content-Type</strong> value can be anything but it is mandatory to have this parameter added to header.</p>

<p>When Scheduler executes the job, a message will be posted to Service Bus Queue or Topic. In Service Bus Explorer screen snapshot below, we can see properties that we set while creating the job
<img src="/images/SBExp.jpg" alt="Service Bus Explorer" /></p>

<p>You can do this from code as well and below is the sample</p>

<pre><code>    using System;
    using Microsoft.WindowsAzure.Scheduler;
    using Microsoft.Azure;
    using Microsoft.WindowsAzure.Scheduler.Models;
    using Microsoft.WindowsAzure.Management.Scheduler;

    namespace SchedulerFault
    {
        public class Scheduler
        {
            private SchedulerClient SchdClient;
            SubscriptionCloudCredentials credentials;
            public Scheduler(SubscriptionCloudCredentials creds)
            {
                credentials = creds;
                SchdClient = new SchedulerClient("&lt;Scheduler Service&gt;", "Job Collection Name", credentials);                
            }

            public void inject()
            {
                var Request = new JobHttpRequest(new Uri(@"&lt;Topic/Queue URI&gt;?timeout=60"), "POST");
                Request.Body = "Test Newton Properties";
                Request.Headers.Add("BrokerProperties", "{\"Label\":\"M2\", \"MessageId\":\"Id1\"}");
                Request.Headers.Add("Content-Type","application/xml");
                Request.Headers.Add("Authorization", "&lt;Access Token&gt;");

                var StartTime = DateTime.Now;
                var Recurrence = new JobRecurrence()
                {
                    Frequency = JobRecurrenceFrequency.Minute,
                    Interval = 1,
                    Count = 5
                };
                var Action = new JobAction();
                Action.Type = JobActionType.Http;
                Action.Request = Request;
                var jobParam = new JobCreateParameters();
                jobParam.Action = Action;
                jobParam.Recurrence = Recurrence;
                jobParam.StartTime = StartTime;

                try
                {
                    var Response = SchdClient.Jobs.Create(jobParam);
                    Console.WriteLine(Response.RequestId);
                    Console.WriteLine(Response.StatusCode);
                    Console.WriteLine(Response.Job.Id);
                }
                catch(Exception ex)
                {
                    Console.WriteLine(ex.Message);            
                }            
            }
        }
    }
</code></pre>

<p>We need to install Microsoft WindowsAzure Management Scheduler Nuget package has necessary SDK for managing Scheduler and jobs in it.</p>

<p>Scheduler service name(first parameter for SchedulerClient constructor) can be obtained from Scheduler dashboard or it follows following format <strong>CS-RegionName-scheduler</strong>. If scheduler is created int Southeast Asia then Service name will be <strong>CS-SoutheastAsia-scheduler</strong>. If it is created in SouthCentralUS then service name will be <strong>CS-SouthCentralUS-scheduler</strong>.</p>

<p>Job Collection name(second parameter for SchedulerClient constructor) is a container in which Job will be created.</p>

<p>Simple aah, If anyone says to you that Azure Scheduler cannot submit messages to Service Bus topic or queue then you know what to say and where to re-direct them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azure Service Bus Partition Queues and Topics? Are they different?]]></title>
    <link href="http://prasad-pillutla.github.io/Prasadthinks/blog/2015/07/02/azure-service-bus-partition-queues-and-topics-are-they-different/"/>
    <updated>2015-07-02T18:21:46+00:00</updated>
    <id>http://prasad-pillutla.github.io/Prasadthinks/blog/2015/07/02/azure-service-bus-partition-queues-and-topics-are-they-different</id>
    <content type="html"><![CDATA[<p>Queues/Topics have been there for longtime and everyone thinks they know everything about them. I would park that discussion for later date and discuss about partitioning, which was introduced as an add-on capability to these services.</p>

<p>In a normal service bus queue/topic there is only message store powered by SQL to store messages. If this message store is not reachable for any reason then entire queue/topic is unavailable. Throughput of queue/topic is limited by this single message store, which more often than not is a bottleneck.</p>

<p>In partitioned queue/topic there are multiple message stores (also called as partition) and, read and write requests are catered by different partitions, which will reduce contention. If a client is writing a message to queue and another client is reading from queue these two operations can happen on two different partitions. This isolation gives boost to performance and improves overall throughput.</p>

<p><em>Behind the scenes</em>
Partitioned queues/topics can be created by enabling a checkbox box in configure queue/topic dialog. By default partitioning is enabled and below screenshots show how to enable/disable partitioning.</p>

<p><strong>Create Queue</strong>
<img src="/images/basic.jpg" alt="Create Queue" /></p>

<p><strong>Configure Queue</strong>
<img src="/images/part.jpg" alt="Configure Queue" /></p>

<p><strong>Queue summary</strong>
<img src="/images/qsummary.jpg" alt="Queue summary" /></p>

<p>In the above screenshots, you can see I mentioned queue size (Max Size) as 1 GB but queue 16 GB queue is created? What could have happened? When partitioning is enabled Azure creates 16 partitions or message stores at the backend, each partition is of the size, which was mentioned during create in configure queue dialog. In the above screenshot, I requested 1 GB queue and enabled partitioning so Azure created 16 partitions each of the size 1 GB (, which I mentioned during create). What if I mentioned 5 GB as queue size during create, I get 80 GB queue (16 partitions each of 5 GB size).</p>

<p>Additional space is fine but how does it impact my reads and writes? As shown in diagram below (for simplicity only 3 partitions are shown), 9 messages (Msg 1 thru Msg 9) are sent to queue and queue internally uses round robin algorithm to send messages into partitions. If there is one receiver reading messages from queue, messages are picked from partitions at random. If we abandon a message after reading it then the message goes back to partition from which it was picked and also doesn’t break sequence in that partition. For example, if we pick Msg 5 in partition 2 and then abandon it, it will still be second message in partition 2. But when next receive call is made by receiver, queue can return message from any partition (could also be Msg 5 again). This can break sequential processing because we are expecting Msg 5 (which will always be the case if the queue doesn’t have partitions) and with partitions there is no gurantee that Msg 5 will be returned.</p>

<p><strong>Message selection</strong>
<img src="/images/process.jpg" alt="Message selection" /></p>

<p>If a partition is unavailable when a client is writing a message into it then queue will send message to next available partition. While reading, message from available partition is returned so there is no wait time like it is in single partition queue and will improve performance. Client application is abstracted from this entire process of partition selection. To enable high availability for queues/topics during local failures it is advised to turn-on partitions during their creation. <em>If sequential processing is a hard requirement then don’t turn-on partitioning</em>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nuances of Azure Event Hubs]]></title>
    <link href="http://prasad-pillutla.github.io/Prasadthinks/blog/2015/06/18/nuances-of-azure-event-hubs/"/>
    <updated>2015-06-18T17:13:27+00:00</updated>
    <id>http://prasad-pillutla.github.io/Prasadthinks/blog/2015/06/18/nuances-of-azure-event-hubs</id>
    <content type="html"><![CDATA[<p>Event Hub, Microsoft’s PaaS offering to accept millions of events per second is built to handle traffic for Internet of Things scenarios. It (Event Hub) is an offshoot of Partitioned queues/topics and leverages same partitioning strategy. I know you would ask, why does Event Hub scale and Queues/Topics don’t? To achieve scale certain features like session based messaging, TTL were let go in Event Hub, which makes it light-weight and achieve the scale.</p>

<p>In this post I’ll not be writing about Event Hubs functionality, which is available on <a href="http://azure.microsoft.com/en-in/services/event-hubs/">MSDN</a> instead I’ll be sharing subtle aspects which are important to know while using Event Hubs.</p>

<p>Event hub speed is measured in Throughput Units (TPU), which defines the maximum event rate (ingress and egress) i.e., 1 Throughput unit equals to 1 MB/sec ingress and 2MB/sec egress and 2 Throughput units equals to 2 MB/sec ingress and 4MB/sec egress and so on.</p>

<p>Event Hubs are designed for downstream parallelism which is why egress rate is double that of Ingress. To understand this better let’s do some math</p>

<p>Ingress rate per partition => (TPU / No of Partitions)</p>

<p>Egress rate per partition => ((TPU * 2) / No of Partitions); Egress is twice of Ingress for TPU</p>

<table>
<thead>
<tr>
<th style="text-align:center;">         TPU  </th>
<th style="text-align:center;">        Partitions </th>
<th style="text-align:center;">            Ingress            </th>
<th style="text-align:right;">          Egress            </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">          1   </td>
<td style="text-align:center;">        8          </td>
<td style="text-align:center;">     0.125 MB/Sec (=> 1/8)     </td>
<td style="text-align:right;">  0.25 MB/Sec (=> 2/8)      </td>
</tr>
<tr>
<td style="text-align:center;">          2   </td>
<td style="text-align:center;">        8          </td>
<td style="text-align:center;">     0.250 MB/Sec (=> 2/8)     </td>
<td style="text-align:right;">  0.50 MB/Sec (=> 4/8)      </td>
</tr>
<tr>
<td style="text-align:center;">          1   </td>
<td style="text-align:center;">       32          </td>
<td style="text-align:center;">     0.03125 MB/Sec (=> 1/32)  </td>
<td style="text-align:right;">  0.0625 MB/Sec (=> 2/32)   </td>
</tr>
<tr>
<td style="text-align:center;">          2   </td>
<td style="text-align:center;">       32          </td>
<td style="text-align:center;">     0.0625 MB/Sec (=> 2/32)   </td>
<td style="text-align:right;">  0.125 MB/Sec (=> 4/32)    </td>
</tr>
</tbody>
</table>


<p> <strong>TPU</strong> - <em>No of Throughput Units</em></p>

<p><strong>Partitions</strong> - <em>Eventhub partitions</em></p>

<p><strong>Ingress</strong> - <em>Ingress rate per partition (MB/Sec)</em></p>

<p><strong>Egress</strong> - <em>Egress rate per partition (MB/Sec)</em></p>

<p>For example, if user selects 1 TPU and 8 partitions and all partitions see even load, each partition gets approximately <em>0.125 MB/Sec</em> ingress throughput for a total aggregate throughput of 1 MB/Sec(8 x 0.125) and if user selects 2 TPU and 8 partitions, each partition gets approximately <em>0.25 MB/Sec</em> (8 x 0.25).</p>

<p>However there is cap on maximum ingress and egress that a partition can deliver, which is 1 MB/sec ingress and 2MB/Sec Egress. For instance, I choose 2 TPUs and 8 Partitions for an Event Hub, and one partition is receiving all of traffic and other partitions are sitting idle. When this partition receives more than 1MB/Sec it starts throttling and doesn’t matter if maximum traffic that Event Hub with 2 TPUs can take is 2MB/Sec.</p>

<p>To summarize, irrespective of load patterns of individual partitions and maximum throughput defined by TPUs selected, <em>a partition cannot take more than 1 MB/Sec ingress</em>.</p>

<p>Let’s say user selects 8 partitions and 10 TPUs for an Event Hub; total ingress that it can support is 10 MB/Sec which means in case of even load distribution each partition will receive 1.25 MB/Sec. How?</p>

<p>=> Each TPU guarantees 1MB/Sec Ingress</p>

<p>=> 10 TPUs will deliver 10 * 1 MB/Sec, which is 10 MB/Sec</p>

<p>=> Total number of partitions to cater traffic is 8</p>

<p>=> Even distribution means 10 MB per Sec/ 8 Partitions, which is 1.25 MB/Sec per Partition</p>

<p>But there is cap on maximum throughput for a partition, which is 1MB/Sec. What does this imply? This means that partitions will throttle if Event Hub is operating at its full capacity. This brings us to most important decision point, Number of Partitions and TPUs have to be selected together and after evaluating load patterns. Event Hub allows changing TPUs anytime but not partitions. Once allocated partitions cannot be increased or decreased and to alter their count Event hub has to be recreated.</p>

<p>Too many parameters to consider aren’t they; let me make it simple with an example. I’ve a scenario where peak traffic volume is 2,000 transactions/Second and each transaction(message) is of size 15 KB. Net volume that Event Hub will have to deal with is</p>

<p>=> 2,000 * 15 KB => 30,000 KB/Sec => 30 MB/Sec (for simplicity 1 MB = 1000 KB)</p>

<p>I choose to have 8 partitions and in the case of even load distribution each partition will receive</p>

<p>=> 30 MB per Sec / 8 Partitions => 3.75 MB/Sec per Partition, which is way more than maximum ingress rate of a partition (1 MB/sec). 8 partitions Event Hub will throttle for above scenario.</p>

<p>Now I configure 32 partitions and in the case of even load distribution each partition will receive</p>

<p>=> 30 MB per Sec / 32 partitions => 0.9375 MB/Sec per Partition, which is less than maximum ingress rate of a partition (1 MB/sec). 32 partitions will cater my requirement (2000 transactions per Sec, each transaction is of 15 KB size) without throttling.</p>

<p>Azure portal allows user to create maximum of 32 partitions and provision upto 20 TPUs. If user requires more throughput units (<em>partitions implied</em>) he/she should contact <a href="http://azure.microsoft.com/en-in/support/options/">Azure support</a>.</p>
]]></content>
  </entry>
  
</feed>
